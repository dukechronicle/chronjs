var api = require('../../api');
var log = require('../../log');

var fs = require('fs');
var path = require('path');
var async = require('async');
var sax = require('sax');
var zipfile = require('zipfile');


exports.runExporter = runExporter;


/**
 * Creates a new ArticleParser object. ArticleParser has a parse method for
 * parsing a zip archive of XML files generated by K4. Once instantiated, an
 * ArticleParser can parse many zip files.
 *
 * @constructor
 * @this{ArticleParser}
 * @param{function} articleCallback A function to call after each article has
 *     been parsed into JSON. articleCallback will be called with a JSON
 *     article and a callback that must be called at the end of the function.
 */
function ArticleParser(articleCallback) {
    var thisParser = this;
    var endWhitespace = /^\s+|\s+$/g;
    var actions = {
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:ID":onId,
        "K4EXPORT:PUBLICATION:ISSUE:PUBLICATIONDATE":onDate,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:SECTION:NAME":onSection,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:METADATA:NAME":onMetadataType,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:METADATA:VALUE:STRING":onMetadata,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:TEXTOBJECTS:TEXTOBJECT:TEXT:INLINETAG":onInlineTag,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:TEXTOBJECTS:TEXTOBJECT:TEXT:INLINETAG:INLINETAG":onInlineTag,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:TEXTOBJECTS:TEXTOBJECT:TEXT:INLINETAG:BREAK":onTextBreak,
        "K4EXPORT:PUBLICATION:ISSUE:ARTICLE:TEXTOBJECTS:TEXTOBJECT:TEXT:INLINETAG:INLINETAG:BREAK":onTextBreak
    };

     /**
     * Parses all XML documents in the given zip archive into Javascript article
     * objects and calls the ArticleParsers articleCallback function on each
     * object. Upon completion, calls the callback function with an array of
     * filenames of articles that could not be parsed and an array of
     * successfully parsed objects as arguments.
     *
     * @param{string} zipPath Path to the zip archive
     * @param{function} callback A callback that takes as parameters an array
     *     of errors and an array of the articles created
     */
    this.parse = function (zipPath, callback) {
        var succeed = [];
        var failed = [];
        var zipFile = new zipfile.ZipFile(zipPath);
        async.forEach(zipFile.names,
                function (name, cb) {
                    if (path.basename(name)[0] == "." ||
                            name[name.length - 1] == "/") {
                        cb();
                    } else {
                        thisParser.parseFile(zipFile, name, function (err, title) {
                            if (err) failed.push(err);
                            else     succeed.push(title);
                            cb();
                        });
                    }
                },
                function (err) {
                    callback(failed, succeed);
                }
        );
    };

    /**
     * Parses a file in a zip archive into an article object. Calls the
     * ArticleParser's registered articleCallback on it. Returns the filename
     * as an error if given file is not an XML or if other error occurs during
     * parsing. If no error, calls callback on article object.
     * 
     * @param{string} zipFile Path to zip archive
     * @param{string} name Name of the file in the archive
     * @param{function} callback Callback function taking error and
     *     article object passed as arguments
     */
    this.parseFile = function(zipFile, name, callback) {
    	var extension = path.extname(name);
	    if (extension == '.xml') {
            zipFile.readFile(name, function(err, data) {
                if (err) {
                    log.warning("Can't open file: " + err);
                    callback(name);
                } else {
                    thisParser.parseXML(data.toString(),
                            function (err, article) {
                                if (err) callback(name);
                                else articleCallback(article, callback);
                            });
                }
            });
        }
        else {
            log.warning("Unknown file type: " + name);
            callback(name);
        }
    };

    this.parseXML = function (xml, callback) {
        var parser = new sax.parser();
        parser.article = { body:[],
            type:'article',
            publish:false
        };
        parser.ontext = function (text) {
            parser.textNode = text.replace(endWhitespace, '');
            async.reduceRight(parser.tags, parser.tag.name,
                    function (memo, item, cb) {
                        cb(undefined, item.name + ":" + memo);
                    },
                    function (err, result) {
                        var action = actions[result];
                        if (action != undefined)
                            action(parser);
                    });
        };
        parser.onend = function () {
            fixArticle(parser.article, callback);
        };
        parser.write(xml).close();
    };

    /**
     * Converts a raw article object with data into format expected by API.
     * Eliminates unnecessary beginning parts of the article. Creates the
     * article teaser, which is the first sentence. Reduces the array of
     * paragraphs into the article body string. Returns an error if the article
     * data isn't present. 
     * 
     * @param{Article} article Raw article object from parseXML
     * @param{function} callback Callback taking the corrected article object
     */
    function fixArticle(article, callback) {
        if (!article.body || !article.title) {
            callback("XML couldn't be parsed");
            return;
        }
        try {
            if (article.taxonomy[0] == "Editorial")
		article.taxonomy = [ "Opinion", "Editorial" ];
            if (article.body[0].match(/^by [^\.]*$/i)) article.body.shift();
            if (article.body[0].match(/^from [^\.]*$/i)) article.body.shift();
            if (article.body[0].match(/^THE CHRONICLE$/)) article.body.shift();
            article.teaser = article.body[0].replace(/\.\s+[A-Z].*$/, ".");
        } catch (err) {
            callback(err);
            return;
        }
        async.reduce(article.body, "",
                function (memo, item, cb) {
                    cb(undefined, memo + "<p>" + item + "</p>");
                },
                function (err, result) {
                    if (err)
                        callback(err);
                    else {
                        article.body = result;
                        callback(undefined, article);
                    }
                });
    }

    function onId(parser) {
        parser.article.import_id = parser.textNode;
    }

    function onSection(parser) {
        parser.article.taxonomy = [ parser.textNode ];
    }

    function onDate(parser) {
        var date = new Date(parser.textNode);
        parser.article.created = date.getTime() / 1000;
    }


    function onMetadataType(parser) {
        parser.metadataType = parser.textNode;
    }


    function onMetadata(parser) {
        if (parser.metadataType == "Author") {
            async.map(parser.textNode.split(/\,\s*and\s|\sand\s|\,/),
                    function (name, cb) {
                        cb(undefined, name.replace(endWhitespace));
                    },
                    function (err, results) {
                        parser.article.authors = results;
                    });
        }
    }


    function onInlineTag(parser) {
        var tag = parser.tag;
        if (tag.attributes.name == "Root")
            parser.article.title = parser.textNode;
        if (tag.attributes.name == "Story")
            parser.article.body.push(parser.textNode);
    }

    function onTextBreak(parser) {
        var tag = parser.tags[parser.tags.length - 1];
        if (tag.attributes.name == "Story")
            parser.article.body.push(parser.textNode);
    }

}


/**
 * Takes a path on the filesystem to the zip file with article XML files. Parses
 * all articles and adds them to the site. Upon completion, the function
 * deletes the zip file and calls a callback function with two arguments: an
 * array of the filenames of the articles that weren't parsed and an array of
 * the successfuly parsed article objects.
 *
 * @param{string} zipPath The path of the zip file with the article XML files
 * @param{function} exportCallback Callback function of failures and successes
 */
function runExporter(zipPath, callback) {
    var parser = new ArticleParser(function (article, callback) {
	api.addDoc(article, function (err, url, id) {
            if (err) {
                log.warning("Error adding article: " + err);
                callback(article.title);
            }
            else {
                article.url = url;
                article.id = id;
                article.renderedBody = article.body;
                callback(undefined, article);
            }
        });
    });

    parser.parse(zipPath, callback);
}
